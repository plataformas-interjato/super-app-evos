import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Alert,
  Image,
  Dimensions,
  Modal,
  TextInput,
  StatusBar,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { RFValue } from 'react-native-responsive-fontsize';
import * as ImagePicker from 'expo-image-picker';
import { WorkOrder, User } from '../types/workOrder';
import { ServiceStep, ServiceStepData } from '../services/serviceStepsService';
import AsyncStorage from '@react-native-async-storage/async-storage';
import BottomNavigation from '../components/BottomNavigation';
import { checkNetworkConnection, saveChecklistEtapaOffline } from '../services/integratedOfflineService';
import imageCompressionService from '../services/imageCompressionService';

const { width } = Dimensions.get('window');

interface PhotoCollectionScreenProps {
  workOrder: WorkOrder;
  user: User;
  onBackPress: () => void;
  onTabPress: (tab: 'home' | 'profile') => void;
  onFinishPhotoCollection: (photos: { [entryId: number]: string }) => void;
  onBackToServiceSteps?: () => void;
}

interface PhotoEntry {
  id: number;
  titulo: string;
  stepTitle: string;
  stepId: number;
  photoUri?: string;
  fotoModelo?: string; // Foto modelo do banco de dados
}

// NOVA INTERFACE: Para fotos extras com m√∫ltiplos containers
interface ExtraPhotoEntry {
  id: string;
  titulo: string;
  stepId: number;
  photoUri?: string;
  created_at: string;
}

const PhotoCollectionScreen: React.FC<PhotoCollectionScreenProps> = ({
  workOrder,
  user,
  onBackPress,
  onTabPress,
  onFinishPhotoCollection,
  onBackToServiceSteps,
}) => {
  const [steps, setSteps] = useState<ServiceStep[]>([]);
  const [activeStepIndex, setActiveStepIndex] = useState(0);
  const [photoEntries, setPhotoEntries] = useState<PhotoEntry[]>([]);
  const [collectedPhotos, setCollectedPhotos] = useState<{ [entryId: number]: string }>({});
  const [isLoading, setIsLoading] = useState(true);
  const [showModelPhotoModal, setShowModelPhotoModal] = useState(false);
  const [selectedEntryForModel, setSelectedEntryForModel] = useState<PhotoEntry | null>(null);
  const stageScrollViewRef = useRef<ScrollView>(null);
  const [comentarios, setComentarios] = useState<{ [stepId: number]: string }>({});
  const [fotosSalvasUsuario, setFotosSalvasUsuario] = useState<{ [entryId: number]: string }>({});
  
  // NOVA FUNCIONALIDADE: Estado para m√∫ltiplas fotos extras por etapa
  const [extraPhotoEntries, setExtraPhotoEntries] = useState<{ [stepId: number]: ExtraPhotoEntry[] }>({});

  // Estados para o modal de foto atual
  const [showCurrentPhotoModal, setShowCurrentPhotoModal] = useState(false);
  const [selectedEntryForCurrent, setSelectedEntryForCurrent] = useState<PhotoEntry | null>(null);
  
  // NOVA FUNCIONALIDADE: Estado para modal de foto extra
  const [showExtraPhotoModal, setShowExtraPhotoModal] = useState(false);
  const [selectedExtraEntry, setSelectedExtraEntry] = useState<ExtraPhotoEntry | null>(null);

  // Estado para armazenar alturas m√≠nimas dos t√≠tulos por etapa
  const [titleHeightsByStep, setTitleHeightsByStep] = useState<{ [stepId: number]: number }>({});

  // Flags de controle para prevenir loops infinitos e execu√ß√µes simult√¢neas
  const [isLoadingSteps, setIsLoadingSteps] = useState(false);
  const [isSavingComment, setIsSavingComment] = useState(false);
  const [lastActiveStepIndex, setLastActiveStepIndex] = useState(-1);
  const [isInitialized, setIsInitialized] = useState(false);
  const [isChangingStep, setIsChangingStep] = useState(false);

  useEffect(() => {
    if (!isInitialized) {
      // Usar timeout para evitar execu√ß√£o imediata que pode causar problemas
      const timeoutId = setTimeout(() => {
        loadServiceSteps();
        setIsInitialized(true);
      }, 100);
      
      return () => clearTimeout(timeoutId);
    }
  }, [isInitialized]);

  // Centralizar o step ativo quando mudar - COM PROTE√á√ÉO CONTRA LOOPS
  useEffect(() => {
    if (steps.length > 0 && stageScrollViewRef.current && activeStepIndex !== lastActiveStepIndex && !isChangingStep) {
      console.log('üéØ Centralizando step:', { activeStepIndex, lastActiveStepIndex });
      
      // Usar timeout para evitar conflitos
      const timeoutId = setTimeout(() => {
        setLastActiveStepIndex(activeStepIndex);
        centerCurrentStage();
      }, 50);
      
      return () => clearTimeout(timeoutId);
    }
  }, [activeStepIndex, steps.length, lastActiveStepIndex, isChangingStep]);

  // Carregar coment√°rio quando a etapa ativa mudar - COM PROTE√á√ÉO CONTRA LOOPS
  useEffect(() => {
    if (steps.length > 0 && activeStepIndex < steps.length && activeStepIndex !== lastActiveStepIndex && !isSavingComment && !isChangingStep) {
      console.log('üí¨ Carregando coment√°rio para step:', activeStepIndex);
      
      // Usar timeout para evitar conflitos
      const timeoutId = setTimeout(() => {
        loadComentarioEtapa(activeStepIndex);
      }, 100);
      
      return () => clearTimeout(timeoutId);
    }
  }, [activeStepIndex, steps.length, lastActiveStepIndex, isSavingComment, isChangingStep]);

  // Fun√ß√£o para centralizar a etapa atual - COM PROTE√á√ÉO CONTRA LOOPS
  const centerCurrentStage = () => {
    if (steps.length > 0 && stageScrollViewRef.current && activeStepIndex >= 0 && activeStepIndex < steps.length) {
      const scrollToIndex = activeStepIndex;
      const buttonWidth = 200;
      const buttonMargin = 20;
      const containerWidth = 375; // Largura fixa para c√°lculo consistente
      
      const scrollToX = (scrollToIndex * (buttonWidth + buttonMargin)) - (containerWidth / 2) + (buttonWidth / 2);
      
      // Usar timeout para evitar conflitos com renderiza√ß√£o
      const timeoutId = setTimeout(() => {
        try {
          stageScrollViewRef.current?.scrollTo({
            x: Math.max(0, scrollToX),
            animated: true,
          });
        } catch (scrollError) {
          console.warn('‚ö†Ô∏è Erro ao centralizar step:', scrollError);
        }
      }, 200);
      
      // Limpar timeout se componente for desmontado
      return () => clearTimeout(timeoutId);
    }
  };

  // Fun√ß√£o para carregar coment√°rio de uma etapa
  const loadComentarioEtapa = async (stepIndex: number) => {
    if (stepIndex >= 0 && stepIndex < steps.length) {
      const currentStep = steps[stepIndex];
      try {
        // BUSCAR COMENT√ÅRIO DIRETO DO ASYNCSTORAGE - SEM REQUISI√á√ïES ONLINE
        const offlineKey = 'offline_comentarios_etapa';
        const existingDataStr = await AsyncStorage.getItem(offlineKey);
        
        if (existingDataStr) {
          const existingData = JSON.parse(existingDataStr);
          const recordKey = `${workOrder.id}-${currentStep.id}`;
          const comentario = existingData[recordKey];
          
          if (comentario && comentario.comentario) {
            setComentarios(prev => ({
              ...prev,
              [currentStep.id]: comentario.comentario
            }));
            console.log('üí¨ Coment√°rio carregado do cache offline');
          }
        }
      } catch (error) {
        console.error('Erro ao carregar coment√°rio da etapa offline:', error);
      }
    }
  };

  // Fun√ß√£o para salvar coment√°rio da etapa atual - COM PROTE√á√ÉO CONTRA LOOPS
  const saveCurrentComentario = async () => {
    // Prote√ß√£o contra execu√ß√µes simult√¢neas
    if (isSavingComment) {
      console.log('‚ö†Ô∏è saveCurrentComentario j√° em execu√ß√£o, ignorando nova chamada');
      return;
    }

    try {
      setIsSavingComment(true);
      
      if (activeStepIndex >= 0 && activeStepIndex < steps.length) {
        const currentStep = steps[activeStepIndex];
        const comentario = comentarios[currentStep.id] || '';
        
        if (comentario.trim()) {
          console.log('üí¨ Salvando coment√°rio da etapa atual OFFLINE:', { stepId: currentStep.id, comentarioLength: comentario.length });
          
          try {
            // SALVAR DIRETO NO ASYNCSTORAGE - SEM IMPORTS DIN√ÇMICOS
            const offlineKey = 'offline_comentarios_etapa';
            const existingDataStr = await AsyncStorage.getItem(offlineKey);
            const existingData = existingDataStr ? JSON.parse(existingDataStr) : {};
            
            const recordKey = `${workOrder.id}-${currentStep.id}`;
            existingData[recordKey] = {
              ordem_servico_id: workOrder.id,
              etapa_id: currentStep.id,
              comentario: comentario.trim(),
              created_at: new Date().toISOString(),
              synced: false
            };
            
            await AsyncStorage.setItem(offlineKey, JSON.stringify(existingData));
            console.log('‚úÖ Coment√°rio salvo offline com sucesso');
          } catch (offlineError) {
            console.error('üí• Erro ao salvar coment√°rio offline:', offlineError);
          }
        } else {
          console.log('üí¨ Coment√°rio vazio, n√£o salvando');
        }
      }
    } catch (error) {
      console.error('üí• Erro inesperado ao salvar coment√°rio:', error);
    } finally {
      setIsSavingComment(false);
    }
  };

  // Fun√ß√£o para atualizar coment√°rio - SEM SALVAMENTO AUTOM√ÅTICO
  const updateComentario = (text: string) => {
    if (activeStepIndex >= 0 && activeStepIndex < steps.length) {
      const currentStep = steps[activeStepIndex];
      setComentarios(prev => ({
        ...prev,
        [currentStep.id]: text
      }));
    }
  };

  const loadServiceSteps = async () => {
    // Prote√ß√£o contra execu√ß√µes simult√¢neas
    if (isLoadingSteps) {
      console.log('‚ö†Ô∏è loadServiceSteps j√° em execu√ß√£o, ignorando nova chamada');
      return;
    }

    setIsLoadingSteps(true);
    setIsLoading(true);
    
    try {
      if (!workOrder.tipo_os_id) {
        console.warn('‚ö†Ô∏è Nenhum tipo_os_id dispon√≠vel');
        setSteps([]);
        setPhotoEntries([]);
        return;
      }

      console.log('üîç Carregando etapas para coleta de fotos...');
      
      // Usar a fun√ß√£o corrigida getServiceStepsWithDataCached
      const { getServiceStepsWithDataCached } = await import('../services/serviceStepsService');
      const { data: stepsFromService, error: serviceError, fromCache } = await getServiceStepsWithDataCached(
        workOrder.tipo_os_id,
        workOrder.id
      );
      
      if (serviceError) {
        console.error('‚ùå Erro ao carregar etapas:', serviceError);
        setSteps([]);
        setPhotoEntries([]);
        return;
      }
      
      if (stepsFromService && stepsFromService.length > 0) {
        const totalEntries = stepsFromService.reduce((sum, step) => sum + (step.entradas?.length || 0), 0);
        console.log(`‚úÖ ${stepsFromService.length} etapas com ${totalEntries} entradas carregadas`);
        
        setSteps(stepsFromService);
        
        // Criar lista de entradas para fotos
        const entries: PhotoEntry[] = [];
        stepsFromService.forEach((step: ServiceStep) => {
          step.entradas?.forEach((entry: ServiceStepData) => {
            const titulo = entry.titulo || entry.valor || `Entrada ${entry.ordem_entrada}`;
            
            entries.push({
              id: entry.id,
              titulo,
              stepTitle: step.titulo,
              stepId: step.id,
              fotoModelo: entry.foto_modelo,
            });
          });
        });
        
        setPhotoEntries(entries);
        console.log(`üì∏ ${entries.length} entradas de foto processadas`);
        
        // Tentar carregar fotos salvas sem bloquear
        if (entries.length > 0) {
          try {
            // Buscar dados da tabela offline primeiro
            const offlineData = await AsyncStorage.getItem('offline_dados_records');
            const offlinePhotos: { [entradaId: number]: string } = {};
            
            if (offlineData) {
              const records = JSON.parse(offlineData);
              Object.values(records).forEach((record: any) => {
                if (record.ordem_servico_id === workOrder.id && record.valor) {
                  offlinePhotos[record.entrada_dados_id] = record.valor;
                }
              });
            }
            
            setFotosSalvasUsuario(offlinePhotos);
            console.log(`üì∏ ${Object.keys(offlinePhotos).length} fotos offline carregadas`);
          } catch (fotosError) {
            console.warn('‚ö†Ô∏è Erro ao carregar fotos offline:', fotosError);
            setFotosSalvasUsuario({});
          }
        }
        
        // NOVA FUNCIONALIDADE: Carregar fotos extras salvas offline
        await loadExtraPhotos();
        
        return;
      }
      
      // Se n√£o encontrou nada
      console.warn('‚ö†Ô∏è Nenhuma etapa encontrada');
      setSteps([]);
      setPhotoEntries([]);
      
    } catch (error) {
      console.error('üí• Erro inesperado ao carregar etapas:', error);
      setSteps([]);
      setPhotoEntries([]);
    } finally {
      setIsLoadingSteps(false);
      setIsLoading(false);
    }
  };

  // NOVA FUNCIONALIDADE: Carregar fotos extras salvas offline
  const loadExtraPhotos = async () => {
    try {
      const offlineExtrasData = await AsyncStorage.getItem('offline_fotos_extras');
      const loadedExtraEntries: { [stepId: number]: ExtraPhotoEntry[] } = {};
      
      if (offlineExtrasData) {
        const extrasRecords = JSON.parse(offlineExtrasData);
        
        // Agrupar por etapa_id
        Object.entries(extrasRecords).forEach(([recordKey, record]: [string, any]) => {
          if (record.ordem_servico_id === workOrder.id && record.valor) {
            const stepId = record.etapa_id;
            
            if (!loadedExtraEntries[stepId]) {
              loadedExtraEntries[stepId] = [];
            }
            
            loadedExtraEntries[stepId].push({
              id: recordKey,
              titulo: record.titulo || `Foto Extra ${loadedExtraEntries[stepId].length + 1}`,
              stepId: stepId,
              photoUri: record.valor,
              created_at: record.created_at || new Date().toISOString()
            });
          }
        });
        
        // Ordenar por data de cria√ß√£o
        Object.keys(loadedExtraEntries).forEach(stepId => {
          loadedExtraEntries[parseInt(stepId)].sort((a, b) => 
            new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
          );
        });
      }
      
      setExtraPhotoEntries(loadedExtraEntries);
      
      const totalExtras = Object.values(loadedExtraEntries).reduce((sum, entries) => sum + entries.length, 0);
      console.log(`üì∏ ${totalExtras} fotos extras carregadas em ${Object.keys(loadedExtraEntries).length} etapas`);
    } catch (error) {
      console.warn('‚ö†Ô∏è Erro ao carregar fotos extras offline:', error);
      setExtraPhotoEntries({});
    }
  };

  const getCurrentStepEntries = (): PhotoEntry[] => {
    if (steps.length === 0 || activeStepIndex >= steps.length) return [];
    
    const currentStep = steps[activeStepIndex];
    return photoEntries.filter(entry => entry.stepId === currentStep.id);
  };

  // Fun√ß√£o para formatar foto modelo (base64 ou URL)
  const formatPhotoUri = (fotoModelo: string): string => {
    if (!fotoModelo) return '';
    
    // Se j√° tem o prefixo data:image, retorna como est√°
    if (fotoModelo.startsWith('data:image/')) {
      return fotoModelo;
    }
    
    // Se parece ser base64 (n√£o tem http/https), adiciona o prefixo
    if (!fotoModelo.startsWith('http')) {
      return `data:image/jpeg;base64,${fotoModelo}`;
    }
    
    // Se √© uma URL, retorna como est√°
    return fotoModelo;
  };

  const takePhoto = async (entryId: number) => {
    // Solicitar permiss√£o da c√¢mera
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert(
        'Permiss√£o Necess√°ria',
        '√â necess√°rio permitir o acesso √† c√¢mera para tirar fotos.'
      );
      return;
    }

    try {
      const result = await ImagePicker.launchCameraAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        quality: 1.0, // M√°xima qualidade inicial para depois comprimir
        allowsEditing: false,
      });

      if (!result.canceled && result.assets[0]) {
        const originalUri = result.assets[0].uri;
        console.log('üì∏ Foto de coleta capturada, iniciando compress√£o...');
        
        let photoUriToSave = originalUri;
        
        try {
          // COMPRESS√ÉO INTELIGENTE
          const compressed = await imageCompressionService.compressImage(originalUri, 'coleta');
          
          console.log(`‚úÖ Foto de coleta comprimida: ${compressed.compressionRatio.toFixed(1)}% redu√ß√£o (${(compressed.originalSize/(1024*1024)).toFixed(2)}MB ‚Üí ${(compressed.compressedSize/(1024*1024)).toFixed(2)}MB)`);
          
          photoUriToSave = compressed.uri;
          
        } catch (compressionError) {
          console.warn('‚ö†Ô∏è Erro na compress√£o da foto de coleta, usando original:', compressionError);
        }
        
        console.log('üíæ Salvando foto no sistema unificado (FileSystem)...');
        
        // Salvar usando sistema unificado (FileSystem) ao inv√©s de AsyncStorage
        try {
          const { default: unifiedOfflineDataService } = await import('../services/unifiedOfflineDataService');
          
          const result = await unifiedOfflineDataService.saveDadosRecord(
            workOrder.id,
            user.id.toString(),
            entryId,
            photoUriToSave
          );
          
          if (result.success) {
            console.log('‚úÖ Foto salva no sistema unificado');
            
            // Atualizar estado local para exibi√ß√£o
            setCollectedPhotos(prev => ({
              ...prev,
              [entryId]: photoUriToSave
            }));
            
            console.log(`‚úÖ Foto salva - entrada ${entryId}`);
          } else {
            console.error('‚ùå Erro ao salvar no sistema unificado:', result.error);
            Alert.alert('Erro', 'N√£o foi poss√≠vel salvar a foto. Tente novamente.');
          }
        } catch (unifiedError) {
          console.error('‚ùå Erro no sistema unificado:', unifiedError);
          Alert.alert('Erro', 'Erro interno ao salvar foto.');
        }
        
        // 2. Criar a√ß√£o no offline_actions APENAS COM URI
        const actionKey = 'offline_actions';
        const existingActionsStr = await AsyncStorage.getItem(actionKey);
        const existingActions = existingActionsStr ? JSON.parse(existingActionsStr) : {};
        
        const actionId = `dados_record_${workOrder.id}_${entryId}_${Date.now()}`;
        existingActions[actionId] = {
          id: actionId,
          type: 'DADOS_RECORD',
          timestamp: new Date().toISOString(),
          workOrderId: workOrder.id,
          technicoId: user.id,
          data: {
            entradaDadosId: entryId,
            photoUri: photoUriToSave, // URI direto sem convers√£o
          },
          synced: false,
          attempts: 0
        };
        
        await AsyncStorage.setItem(actionKey, JSON.stringify(existingActions));
        
        // Restaurar StatusBar ap√≥s captura
        setTimeout(() => {
          StatusBar.setBackgroundColor('#3b82f6', true);
          StatusBar.setBarStyle('light-content', true);
        }, 50);
      }
    } catch (error) {
      Alert.alert('Erro', 'N√£o foi poss√≠vel tirar a foto. Tente novamente.');
      console.error('Erro ao tirar foto:', error);
    } finally {
      // Garantir que o StatusBar seja restaurado mesmo em caso de erro
      setTimeout(() => {
        StatusBar.setBackgroundColor('#3b82f6', true);
        StatusBar.setBarStyle('light-content', true);
      }, 100);
    }
  };

  const takePhotoFromModal = async () => {
    try {
      if (!selectedEntryForModel) {
        console.warn('‚ö†Ô∏è Nenhuma entrada selecionada para o modal');
        return;
      }
      
      // Fechar modal primeiro
      closeModelPhotoModal();
      
      // Solicitar permiss√£o da c√¢mera
      const { status } = await ImagePicker.requestCameraPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert(
          'Permiss√£o Necess√°ria',
          '√â necess√°rio permitir o acesso √† c√¢mera para tirar fotos.'
        );
        return;
      }

      try {
        const result = await ImagePicker.launchCameraAsync({
          mediaTypes: ImagePicker.MediaTypeOptions.Images,
          quality: 1.0, // M√°xima qualidade inicial para depois comprimir
          allowsEditing: false,
        });

        if (!result.canceled && result.assets[0]) {
          const originalUri = result.assets[0].uri;
          console.log('üì∏ Foto de coleta (modal) capturada, iniciando compress√£o...');
          
          let photoUriToSave = originalUri;
          
          try {
            // COMPRESS√ÉO INTELIGENTE
            const compressed = await imageCompressionService.compressImage(originalUri, 'coleta');
            
            console.log(`‚úÖ Foto de coleta (modal) comprimida: ${compressed.compressionRatio.toFixed(1)}% redu√ß√£o`);
            
            photoUriToSave = compressed.uri;
            
          } catch (compressionError) {
            console.warn('‚ö†Ô∏è Erro na compress√£o da foto de coleta (modal), usando original:', compressionError);
          }
          
          console.log('üíæ Salvando foto no sistema unificado (FileSystem)...');
          
          // Salvar usando sistema unificado (FileSystem) ao inv√©s de AsyncStorage
          try {
            const { default: unifiedOfflineDataService } = await import('../services/unifiedOfflineDataService');
            
            const result = await unifiedOfflineDataService.saveDadosRecord(
              workOrder.id,
              user.id.toString(),
              selectedEntryForModel.id,
              photoUriToSave
            );
            
            if (result.success) {
              console.log('‚úÖ Foto salva no sistema unificado');
              
              // Atualizar estado local para exibi√ß√£o
              setCollectedPhotos(prev => ({
                ...prev,
                [selectedEntryForModel.id]: photoUriToSave
              }));
              
              console.log(`‚úÖ Foto salva - entrada ${selectedEntryForModel.id}`);
            } else {
              console.error('‚ùå Erro ao salvar no sistema unificado:', result.error);
              Alert.alert('Erro', 'N√£o foi poss√≠vel salvar a foto. Tente novamente.');
            }
          } catch (unifiedError) {
            console.error('‚ùå Erro no sistema unificado:', unifiedError);
            Alert.alert('Erro', 'Erro interno ao salvar foto.');
          }
          
          // 2. Criar a√ß√£o no offline_actions APENAS COM URI
          const actionKey = 'offline_actions';
          const existingActionsStr = await AsyncStorage.getItem(actionKey);
          const existingActions = existingActionsStr ? JSON.parse(existingActionsStr) : {};
          
          const actionId = `dados_record_${workOrder.id}_${selectedEntryForModel.id}_${Date.now()}`;
          existingActions[actionId] = {
            id: actionId,
            type: 'DADOS_RECORD',
            timestamp: new Date().toISOString(),
            workOrderId: workOrder.id,
            technicoId: user.id,
            data: {
              entradaDadosId: selectedEntryForModel.id,
              photoUri: photoUriToSave, // URI direto sem convers√£o
            },
            synced: false,
            attempts: 0
          };
          
          await AsyncStorage.setItem(actionKey, JSON.stringify(existingActions));
          
          // 3. Adicionar ao estado local para exibi√ß√£o (usando URI direto)
          console.log(`üíæ Adicionando foto ao estado local para entrada ${selectedEntryForModel.id}`);
          setCollectedPhotos(prev => {
            const newState = {
              ...prev,
              [selectedEntryForModel.id]: photoUriToSave
            };
            console.log(`üìä Estado atualizado:`, {
              entradaId: selectedEntryForModel.id,
              photoUri: photoUriToSave.substring(0, 30) + '...',
              estadoAnterior: Object.keys(prev),
              estadoNovo: Object.keys(newState)
            });
            return newState;
          });
          
          console.log(`‚úÖ Foto salva com URI direto para entrada ${selectedEntryForModel.id}`);
          console.log('üì± Foto ser√° convertida para base64 apenas durante sincroniza√ß√£o');
          
          // Restaurar StatusBar ap√≥s captura
          setTimeout(() => {
            StatusBar.setBackgroundColor('#3b82f6', true);
            StatusBar.setBarStyle('light-content', true);
          }, 50);
        }
      } catch (cameraError) {
        console.error('üí• Erro ao acessar c√¢mera:', cameraError);
        Alert.alert('Erro', 'N√£o foi poss√≠vel acessar a c√¢mera. Tente novamente.');
      }
    } catch (error) {
      console.error('üí• Erro na fun√ß√£o takePhotoFromModal:', error);
      Alert.alert('Erro', 'Erro inesperado. Tente novamente.');
    } finally {
      // Garantir que o StatusBar seja restaurado mesmo em caso de erro
      setTimeout(() => {
        StatusBar.setBackgroundColor('#3b82f6', true);
        StatusBar.setBarStyle('light-content', true);
      }, 100);
    }
  };

  const removePhotoFromModal = () => {
    if (!selectedEntryForCurrent) return;
    
    Alert.alert(
      'Confirmar Remo√ß√£o',
      'Tem certeza que deseja remover esta foto?',
      [
        { text: 'Cancelar', style: 'cancel' },
        { 
          text: 'Remover', 
          style: 'destructive',
          onPress: () => {
            const entryId = selectedEntryForCurrent.id;
            const hasPhoto = collectedPhotos[entryId];
            const hasFotoSalva = fotosSalvasUsuario[entryId];
            
            if (hasPhoto) {
              // Se √© foto da sess√£o atual, remover da sess√£o
              console.log(`üóëÔ∏è Removendo foto da sess√£o via modal (entrada ${entryId})`);
              removePhoto(entryId);
            } else if (hasFotoSalva) {
              // Se √© foto salva, remover do estado local
              console.log(`üóëÔ∏è Removendo foto salva via modal (entrada ${entryId})`);
              setFotosSalvasUsuario(prev => {
                const updated = { ...prev };
                delete updated[entryId];
                return updated;
              });
            }
            
            // Fechar modal ap√≥s remo√ß√£o
            closeCurrentPhotoModal();
          }
        }
      ]
    );
  };

  const removePhoto = (entryId: number) => {
    setCollectedPhotos(prev => {
      const updated = { ...prev };
      delete updated[entryId];
      return updated;
    });
  };

  // NOVA FUNCIONALIDADE: Adicionar nova entrada de foto extra
  const addExtraPhotoEntry = (stepId: number) => {
    const currentEntries = extraPhotoEntries[stepId] || [];
    const newEntry: ExtraPhotoEntry = {
      id: `extra_${workOrder.id}_${stepId}_${Date.now()}`,
      titulo: `Foto Extra ${currentEntries.length + 1}`,
      stepId: stepId,
      created_at: new Date().toISOString()
    };
    
    setExtraPhotoEntries(prev => ({
      ...prev,
      [stepId]: [...(prev[stepId] || []), newEntry]
    }));
  };

  // NOVA FUNCIONALIDADE: Remover entrada de foto extra
  const removeExtraPhotoEntry = (stepId: number, entryId: string) => {
    Alert.alert(
      'Confirmar Remo√ß√£o',
      'Tem certeza que deseja remover este container de foto extra?',
      [
        { text: 'Cancelar', style: 'cancel' },
        { 
          text: 'Remover', 
          style: 'destructive',
          onPress: async () => {
            // Remover do AsyncStorage se existir
            try {
              const offlineExtrasData = await AsyncStorage.getItem('offline_fotos_extras');
              if (offlineExtrasData) {
                const extrasRecords = JSON.parse(offlineExtrasData);
                if (extrasRecords[entryId]) {
                  delete extrasRecords[entryId];
                  await AsyncStorage.setItem('offline_fotos_extras', JSON.stringify(extrasRecords));
                }
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Erro ao remover foto extra do AsyncStorage:', error);
            }
            
            // Remover do estado local
            setExtraPhotoEntries(prev => {
              const updated = { ...prev };
              if (updated[stepId]) {
                updated[stepId] = updated[stepId].filter(entry => entry.id !== entryId);
                if (updated[stepId].length === 0) {
                  delete updated[stepId];
                }
              }
              return updated;
            });
          }
        }
      ]
    );
  };

  // NOVA FUNCIONALIDADE: Tirar foto para entrada espec√≠fica
  const takeExtraPhoto = async (extraEntry: ExtraPhotoEntry) => {
    // Solicitar permiss√£o da c√¢mera
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert(
        'Permiss√£o Necess√°ria',
        '√â necess√°rio permitir o acesso √† c√¢mera para tirar fotos.'
      );
      return;
    }

    try {
      const result = await ImagePicker.launchCameraAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        quality: 0.8,
        allowsEditing: false,
      });

      if (!result.canceled && result.assets[0]) {
        const photoUri = result.assets[0].uri;
        
        console.log('üíæ Salvando foto extra URI direto no AsyncStorage (SEM convers√£o base64)...');
        
        // 1. Salvar no offline_fotos_extras APENAS O URI (sem convers√£o base64)
        const offlineKey = 'offline_fotos_extras';
        const existingDataStr = await AsyncStorage.getItem(offlineKey);
        const existingData = existingDataStr ? JSON.parse(existingDataStr) : {};
        
        existingData[extraEntry.id] = {
          ativo: 1,
          valor: photoUri, // Salvar URI direto sem convers√£o
          ordem_servico_id: workOrder.id,
          etapa_id: extraEntry.stepId,
          titulo: extraEntry.titulo,
          tipo: 'FOTO_EXTRA',
          created_at: extraEntry.created_at,
          synced: false
        };
        
        await AsyncStorage.setItem(offlineKey, JSON.stringify(existingData));
        
        // 2. Criar a√ß√£o no offline_actions APENAS COM URI
        const actionKey = 'offline_actions';
        const existingActionsStr = await AsyncStorage.getItem(actionKey);
        const existingActions = existingActionsStr ? JSON.parse(existingActionsStr) : {};
        
        const actionId = `foto_extra_${workOrder.id}_${extraEntry.stepId}_${Date.now()}`;
        existingActions[actionId] = {
          id: actionId,
          type: 'DADOS_RECORD',
          timestamp: new Date().toISOString(),
          workOrderId: workOrder.id,
          technicoId: user.id,
          data: {
            entradaDadosId: null, // Usar null para indicar foto extra
            photoUri: photoUri, // URI direto sem convers√£o
            extraData: {
              etapaId: extraEntry.stepId,
              titulo: extraEntry.titulo,
              tipo: 'FOTO_EXTRA'
            }
          },
          synced: false,
          attempts: 0
        };
        
        await AsyncStorage.setItem(actionKey, JSON.stringify(existingActions));
        
        // 3. Atualizar estado local (usando URI direto)
        setExtraPhotoEntries(prev => ({
          ...prev,
          [extraEntry.stepId]: prev[extraEntry.stepId].map(entry => 
            entry.id === extraEntry.id ? { ...entry, photoUri: photoUri } : entry
          )
        }));
        
        console.log('‚úÖ Foto extra salva com URI direto');
        console.log('üì± Foto ser√° convertida para base64 apenas durante sincroniza√ß√£o');
        
        // Restaurar StatusBar ap√≥s captura
        setTimeout(() => {
          StatusBar.setBackgroundColor('#3b82f6', true);
          StatusBar.setBarStyle('light-content', true);
        }, 50);
      }
    } catch (error) {
      Alert.alert('Erro', 'N√£o foi poss√≠vel tirar a foto extra. Tente novamente.');
      console.error('Erro ao tirar foto extra:', error);
    } finally {
      // Garantir que o StatusBar seja restaurado mesmo em caso de erro
      setTimeout(() => {
        StatusBar.setBackgroundColor('#3b82f6', true);
        StatusBar.setBarStyle('light-content', true);
      }, 100);
    }
  };

  // NOVA FUNCIONALIDADE: Fun√ß√µes para modal de foto extra
  const openExtraPhotoModal = (extraEntry: ExtraPhotoEntry) => {
    setSelectedExtraEntry(extraEntry);
    setShowExtraPhotoModal(true);
  };

  const closeExtraPhotoModal = () => {
    setShowExtraPhotoModal(false);
    setSelectedExtraEntry(null);
  };

  const takeExtraPhotoFromModal = async () => {
    if (!selectedExtraEntry) return;
    
    // Fechar modal primeiro
    closeExtraPhotoModal();
    
    // Solicitar permiss√£o da c√¢mera
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert(
        'Permiss√£o Necess√°ria',
        '√â necess√°rio permitir o acesso √† c√¢mera para tirar fotos.'
      );
      return;
    }

    try {
      const result = await ImagePicker.launchCameraAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        quality: 0.8,
        allowsEditing: false,
      });

      if (!result.canceled && result.assets[0]) {
        const photoUri = result.assets[0].uri;
        
        console.log('üíæ Salvando foto extra via modal URI direto no AsyncStorage (SEM convers√£o base64)...');
        
        // 1. Salvar no offline_fotos_extras APENAS O URI (sem convers√£o base64)
        const offlineKey = 'offline_fotos_extras';
        const existingDataStr = await AsyncStorage.getItem(offlineKey);
        const existingData = existingDataStr ? JSON.parse(existingDataStr) : {};
        
        existingData[selectedExtraEntry.id] = {
          ativo: 1,
          valor: photoUri, // Salvar URI direto sem convers√£o
          ordem_servico_id: workOrder.id,
          etapa_id: selectedExtraEntry.stepId,
          titulo: selectedExtraEntry.titulo,
          tipo: 'FOTO_EXTRA',
          created_at: selectedExtraEntry.created_at,
          synced: false
        };
        
        await AsyncStorage.setItem(offlineKey, JSON.stringify(existingData));
        
        // 2. Criar a√ß√£o no offline_actions APENAS COM URI
        const actionKey = 'offline_actions';
        const existingActionsStr = await AsyncStorage.getItem(actionKey);
        const existingActions = existingActionsStr ? JSON.parse(existingActionsStr) : {};
        
        const actionId = `foto_extra_modal_${workOrder.id}_${selectedExtraEntry.stepId}_${Date.now()}`;
        existingActions[actionId] = {
          id: actionId,
          type: 'DADOS_RECORD',
          timestamp: new Date().toISOString(),
          workOrderId: workOrder.id,
          technicoId: user.id,
          data: {
            entradaDadosId: null, // Usar null para indicar foto extra
            photoUri: photoUri, // URI direto sem convers√£o
            extraData: {
              etapaId: selectedExtraEntry.stepId,
              titulo: selectedExtraEntry.titulo,
              tipo: 'FOTO_EXTRA'
            }
          },
          synced: false,
          attempts: 0
        };
        
        await AsyncStorage.setItem(actionKey, JSON.stringify(existingActions));
        
        // 3. Atualizar estado local (usando URI direto)
        setExtraPhotoEntries(prev => ({
          ...prev,
          [selectedExtraEntry.stepId]: prev[selectedExtraEntry.stepId].map(entry => 
            entry.id === selectedExtraEntry.id ? { ...entry, photoUri: photoUri } : entry
          )
        }));
        
        console.log('‚úÖ Foto extra via modal salva com URI direto');
        console.log('üì± Foto ser√° convertida para base64 apenas durante sincroniza√ß√£o');
        
        // Restaurar StatusBar ap√≥s captura
        setTimeout(() => {
          StatusBar.setBackgroundColor('#3b82f6', true);
          StatusBar.setBarStyle('light-content', true);
        }, 50);
      }
    } catch (error) {
      Alert.alert('Erro', 'N√£o foi poss√≠vel tirar a foto extra. Tente novamente.');
      console.error('Erro ao tirar foto extra:', error);
    } finally {
      // Garantir que o StatusBar seja restaurado mesmo em caso de erro
      setTimeout(() => {
        StatusBar.setBackgroundColor('#3b82f6', true);
        StatusBar.setBarStyle('light-content', true);
      }, 100);
    }
  };

  const removeExtraPhotoFromModal = () => {
    if (!selectedExtraEntry) return;
    
    Alert.alert(
      'Confirmar Remo√ß√£o',
      'Tem certeza que deseja remover esta foto extra?',
      [
        { text: 'Cancelar', style: 'cancel' },
        { 
          text: 'Remover', 
          style: 'destructive',
          onPress: () => {
            // Remover apenas a foto, n√£o o container
            setExtraPhotoEntries(prev => ({
              ...prev,
              [selectedExtraEntry.stepId]: prev[selectedExtraEntry.stepId].map(entry => 
                entry.id === selectedExtraEntry.id ? { ...entry, photoUri: undefined } : entry
              )
            }));
            
            // Remover do AsyncStorage
            AsyncStorage.getItem('offline_fotos_extras').then(offlineExtrasData => {
              if (offlineExtrasData) {
                const extrasRecords = JSON.parse(offlineExtrasData);
                if (extrasRecords[selectedExtraEntry.id]) {
                  delete extrasRecords[selectedExtraEntry.id];
                  AsyncStorage.setItem('offline_fotos_extras', JSON.stringify(extrasRecords));
                }
              }
            });
            
            closeExtraPhotoModal();
          }
        }
      ]
    );
  };

  const openModelPhotoModal = (entry: PhotoEntry) => {
    setSelectedEntryForModel(entry);
    setShowModelPhotoModal(true);
  };

  const closeModelPhotoModal = () => {
    setShowModelPhotoModal(false);
    setSelectedEntryForModel(null);
  };

  const openCurrentPhotoModal = (entry: PhotoEntry) => {
    setSelectedEntryForCurrent(entry);
    setShowCurrentPhotoModal(true);
  };

  const closeCurrentPhotoModal = () => {
    setShowCurrentPhotoModal(false);
    setSelectedEntryForCurrent(null);
  };

  // Fun√ß√£o de back personalizada que considera a etapa atual
  const handleBackPress = async () => {
    // Salvar coment√°rio da etapa atual antes de qualquer a√ß√£o
    await saveCurrentComentario();

    // Se n√£o estiver na primeira etapa, voltar para a etapa anterior
    if (activeStepIndex > 0) {
      console.log(`üì± Voltando da etapa ${activeStepIndex + 1} para etapa ${activeStepIndex}`);
      setActiveStepIndex(activeStepIndex - 1);
      return;
    }

    // Se estiver na primeira etapa (√≠ndice 0), voltar para a tela anterior
    try {
      console.log('üì± Na primeira etapa, voltando para tela anterior...');
      
      // SIMPLIFICADO: Sempre voltar para ServiceSteps se a fun√ß√£o existir, sen√£o voltar normalmente
      if (onBackToServiceSteps) {
        console.log('‚úÖ Voltando para etapas/checklist');
        onBackToServiceSteps();
      } else {
        console.log('üì± Voltando normalmente');
        onBackPress();
      }
    } catch (error) {
      console.error('üí• Erro inesperado no back:', error);
      // Em caso de erro, voltar normalmente
      onBackPress();
    }
  };

  const handleNext = async () => {
    // Prote√ß√£o contra mudan√ßas simult√¢neas
    if (isChangingStep) {
      console.log('‚ö†Ô∏è Mudan√ßa de step j√° em progresso, ignorando');
      return;
    }

    if (activeStepIndex < steps.length - 1) {
      try {
        setIsChangingStep(true);
        
        // Salvar coment√°rio da etapa atual antes de avan√ßar
        await saveCurrentComentario();
        
        console.log(`üîÑ Avan√ßando da etapa ${activeStepIndex} para ${activeStepIndex + 1}`);
        setActiveStepIndex(activeStepIndex + 1);
      } catch (error) {
        console.error('üí• Erro ao avan√ßar etapa:', error);
      } finally {
        setTimeout(() => setIsChangingStep(false), 500);
      }
    }
  };

  const handlePrevious = async () => {
    // Prote√ß√£o contra mudan√ßas simult√¢neas
    if (isChangingStep) {
      console.log('‚ö†Ô∏è Mudan√ßa de step j√° em progresso, ignorando');
      return;
    }

    if (activeStepIndex > 0) {
      try {
        setIsChangingStep(true);
        
        // Salvar coment√°rio da etapa atual antes de voltar
        await saveCurrentComentario();
        
        console.log(`üîÑ Voltando da etapa ${activeStepIndex} para ${activeStepIndex - 1}`);
        setActiveStepIndex(activeStepIndex - 1);
      } catch (error) {
        console.error('üí• Erro ao voltar etapa:', error);
      } finally {
        setTimeout(() => setIsChangingStep(false), 500);
      }
    }
  };

  const handleFinish = async () => {
    try {
      // Salvar coment√°rio da etapa atual antes de finalizar
      await saveCurrentComentario();
      
      const totalEntries = photoEntries.length;
      
      // CORRIGIDO: Contar tanto fotos da sess√£o atual quanto fotos j√° salvas
      let photosCollected = 0;
      photoEntries.forEach((entry) => {
        const hasPhoto = collectedPhotos[entry.id]; // Foto da sess√£o atual
        const hasFotoSalva = fotosSalvasUsuario[entry.id]; // Foto j√° salva pelo usu√°rio
        
        if (hasPhoto || hasFotoSalva) {
          photosCollected++;
        }
      });
      
      console.log(`üìä Contagem de fotos: ${photosCollected} de ${totalEntries} fotos coletadas`);
      console.log(`üì∏ Fotos da sess√£o atual:`, Object.keys(collectedPhotos).length);
      console.log(` Fotos j√° salvas:`, Object.keys(fotosSalvasUsuario).length);
      
      Alert.alert(
        'Continuar para Finaliza√ß√£o',
        `Voc√™ coletou ${photosCollected} de ${totalEntries} fotos poss√≠veis.\n\nDeseja continuar para a finaliza√ß√£o da ordem de servi√ßo?`,
        [
          { text: 'Cancelar', style: 'cancel' },
          { 
            text: 'Continuar', 
            onPress: () => onFinishPhotoCollection(collectedPhotos)
          }
        ]
      );
    } catch (error) {
      console.error('üí• Erro ao finalizar:', error);
    }
  };

  const handleStepPress = async (index: number) => {
    // Prote√ß√£o contra mudan√ßas simult√¢neas
    if (isChangingStep || index === activeStepIndex) {
      console.log('‚ö†Ô∏è Mudan√ßa de step j√° em progresso ou step √© o mesmo, ignorando');
      return;
    }

    try {
      setIsChangingStep(true);
      
      // Salvar coment√°rio da etapa atual antes de trocar
      await saveCurrentComentario();
      
      console.log(`üîÑ Mudando para etapa ${index}`);
      setActiveStepIndex(index);
    } catch (error) {
      console.error('üí• Erro ao mudar etapa:', error);
    } finally {
      setTimeout(() => setIsChangingStep(false), 500);
    }
  };

  // Fun√ß√£o para calcular altura necess√°ria para um texto
  const calculateTextHeight = (text: string, maxWidth: number): number => {
    const fontSize = RFValue(12);
    const lineHeight = fontSize * 1.4; // Aproximadamente 1.4x o tamanho da fonte
    const characterWidth = fontSize * 0.6; // Aproximadamente 0.6x o tamanho da fonte
    const charactersPerLine = Math.floor(maxWidth / characterWidth);
    const numberOfLines = Math.max(1, Math.ceil(text.length / charactersPerLine));
    
    return numberOfLines * lineHeight + 20; // + 20 para padding
  };

  // Fun√ß√£o para calcular alturas m√≠nimas dos t√≠tulos por etapa
  const calculateTitleHeights = () => {
    if (photoEntries.length === 0 || steps.length === 0) return;

    const cardWidth = (width - 60) / 2; // Largura do card
    const titleWidth = cardWidth - 30; // Largura do t√≠tulo (descontando padding)
    const heightsByStep: { [stepId: number]: number } = {};

    // Para cada etapa, encontrar a altura m√°xima necess√°ria
    steps.forEach(step => {
      const stepEntries = photoEntries.filter(entry => entry.stepId === step.id);
      let maxHeight = 0;

      stepEntries.forEach(entry => {
        const height = calculateTextHeight(entry.titulo, titleWidth);
        maxHeight = Math.max(maxHeight, height);
      });

      heightsByStep[step.id] = maxHeight || 40; // Altura m√≠nima de 40
    });

    setTitleHeightsByStep(heightsByStep);
  };

  // Recalcular alturas quando photoEntries ou steps mudarem
  useEffect(() => {
    if (photoEntries.length > 0 && steps.length > 0) {
      calculateTitleHeights();
    }
  }, [photoEntries, steps]);

  const renderPhotoCard = (entry: PhotoEntry) => {
    const hasPhoto = collectedPhotos[entry.id]; // Foto da sess√£o atual
    const hasFotoSalva = fotosSalvasUsuario[entry.id]; // Foto j√° salva pelo usu√°rio
    const hasFotoModelo = entry.fotoModelo; // Foto modelo do banco
    
    // NOVA REGRA: Sempre mostrar tracejado inicialmente
    // S√≥ mostrar a foto se foi capturada na sess√£o atual OU se j√° tinha foto salva
    let shouldShowPhoto = hasPhoto || hasFotoSalva;
    let photoToShow = null;
    
    if (shouldShowPhoto) {
      if (hasPhoto) {
        photoToShow = hasPhoto; // Foto da sess√£o atual
      } else if (hasFotoSalva) {
        photoToShow = hasFotoSalva; // Foto j√° salva pelo usu√°rio
      }
    }

    // Obter altura m√≠nima do t√≠tulo para esta etapa
    const currentStep = steps[activeStepIndex];
    const titleMinHeight = titleHeightsByStep[currentStep?.id] || 40;
    
    return (
      <View key={entry.id} style={styles.photoCard}>
        <View style={[styles.photoCardTitleContainer, { minHeight: titleMinHeight }]}>
          <Text style={styles.photoCardTitle}>{entry.titulo}</Text>
        </View>
        
        <View style={styles.photoContainer}>
          <TouchableOpacity
            style={[
              styles.photoArea,
              shouldShowPhoto && styles.photoAreaWithCapturedImage, // Verde apenas quando h√° foto para mostrar
            ]}
            onPress={() => {
              // NOVA REGRA: Se j√° tem foto, abrir modal da foto atual
              if (shouldShowPhoto) {
                console.log(`üì∑ Abrindo modal da foto atual (entrada ${entry.id})`);
                openCurrentPhotoModal(entry);
              }
              // Se n√£o tem foto mas tem foto modelo, abrir modal da foto modelo
              else if (hasFotoModelo) {
                console.log(`üñºÔ∏è Abrindo modal da foto modelo (entrada ${entry.id})`);
                openModelPhotoModal(entry);
              }
              // Se n√£o tem foto modelo, abrir c√¢mera diretamente
              else {
                console.log(`üì∑ Abrindo c√¢mera diretamente (entrada ${entry.id})`);
                takePhoto(entry.id);
              }
            }}
          >
            {shouldShowPhoto && photoToShow ? (
              <Image source={{ uri: photoToShow }} style={styles.photoImage} />
            ) : (
              <Ionicons name="camera" size={40} color="#000000" />
            )}
          </TouchableOpacity>
          
          {/* Mostrar bot√£o de remo√ß√£o apenas quando h√° foto capturada na sess√£o atual ou foto salva */}
          {shouldShowPhoto && (
            <TouchableOpacity
              style={styles.removePhotoButton}
              onPress={() => {
                Alert.alert(
                  'Confirmar Remo√ß√£o',
                  'Tem certeza que deseja remover esta foto?',
                  [
                    { text: 'Cancelar', style: 'cancel' },
                    { 
                      text: 'Remover', 
                      style: 'destructive',
                      onPress: () => {
                        if (hasPhoto) {
                          // Se √© foto da sess√£o atual, remover da sess√£o
                          console.log(`üóëÔ∏è Removendo foto da sess√£o (entrada ${entry.id})`);
                          removePhoto(entry.id);
                        } else if (hasFotoSalva) {
                          // Se √© foto salva, remover do estado local (volta para tracejado)
                          console.log(`üóëÔ∏è Removendo foto salva do estado local (entrada ${entry.id})`);
                          setFotosSalvasUsuario(prev => {
                            const updated = { ...prev };
                            delete updated[entry.id];
                            return updated;
                          });
                        }
                      }
                    }
                  ]
                );
              }}
            >
              <Ionicons name="trash" size={16} color="#ef4444" />
            </TouchableOpacity>
          )}
        </View>
      </View>
    );
  };

  // NOVA FUNCIONALIDADE: Renderizar card de foto extra
  const renderExtraPhotoCard = (extraEntry: ExtraPhotoEntry) => {
    const hasPhoto = !!extraEntry.photoUri;
    
    // Obter altura m√≠nima do t√≠tulo para esta etapa
    const currentStep = steps[activeStepIndex];
    const titleMinHeight = titleHeightsByStep[currentStep?.id] || 40;
    
    return (
      <View key={extraEntry.id} style={styles.photoCard}>
        <View style={[styles.photoCardTitleContainer, { minHeight: titleMinHeight }]}>
          <Text style={styles.photoCardTitle}>{extraEntry.titulo}</Text>
          {/* Bot√£o para remover container */}
          <TouchableOpacity
            style={styles.removeContainerButton}
            onPress={() => removeExtraPhotoEntry(extraEntry.stepId, extraEntry.id)}
          >
            <Ionicons name="close-circle" size={20} color="#ef4444" />
          </TouchableOpacity>
        </View>
        
        <View style={styles.photoContainer}>
          <TouchableOpacity
            style={[
              styles.photoArea,
              hasPhoto && styles.photoAreaWithCapturedImage,
            ]}
            onPress={() => {
              if (hasPhoto) {
                console.log(`üì∑ Abrindo modal da foto extra (${extraEntry.id})`);
                openExtraPhotoModal(extraEntry);
              } else {
                console.log(`üì∑ Tirando foto extra (${extraEntry.id})`);
                takeExtraPhoto(extraEntry);
              }
            }}
          >
            {hasPhoto && extraEntry.photoUri ? (
              <Image source={{ uri: extraEntry.photoUri }} style={styles.photoImage} />
            ) : (
              <Ionicons name="camera" size={40} color="#000000" />
            )}
          </TouchableOpacity>
          
          {/* Bot√£o de remo√ß√£o da foto */}
          {hasPhoto && (
            <TouchableOpacity
              style={styles.removePhotoButton}
              onPress={() => {
                Alert.alert(
                  'Confirmar Remo√ß√£o',
                  'Tem certeza que deseja remover esta foto extra?',
                  [
                    { text: 'Cancelar', style: 'cancel' },
                    { 
                      text: 'Remover', 
                      style: 'destructive',
                      onPress: () => {
                        // Remover apenas a foto, manter o container
                        setExtraPhotoEntries(prev => ({
                          ...prev,
                          [extraEntry.stepId]: prev[extraEntry.stepId].map(entry => 
                            entry.id === extraEntry.id ? { ...entry, photoUri: undefined } : entry
                          )
                        }));
                        
                        // Remover do AsyncStorage
                        AsyncStorage.getItem('offline_fotos_extras').then(offlineExtrasData => {
                          if (offlineExtrasData) {
                            const extrasRecords = JSON.parse(offlineExtrasData);
                            if (extrasRecords[extraEntry.id]) {
                              delete extrasRecords[extraEntry.id];
                              AsyncStorage.setItem('offline_fotos_extras', JSON.stringify(extrasRecords));
                            }
                          }
                        });
                      }
                    }
                  ]
                );
              }}
            >
              <Ionicons name="trash" size={16} color="#ef4444" />
            </TouchableOpacity>
          )}
        </View>
      </View>
    );
  };

  // For√ßar restaura√ß√£o do StatusBar ap√≥s mudan√ßas de foto
  useEffect(() => {
    // Pequeno delay para garantir que qualquer interfer√™ncia do ImagePicker tenha terminado
    const timeout = setTimeout(() => {
      StatusBar.setBackgroundColor('#3b82f6', true);
      StatusBar.setBarStyle('light-content', true);
    }, 100);

    return () => clearTimeout(timeout);
  }, [collectedPhotos, fotosSalvasUsuario]);

  if (isLoading) {
    return (
      <SafeAreaView style={styles.container} edges={['top']}>
        <View style={styles.loadingContainer}>
          <Text style={styles.loadingText}>Carregando etapas...</Text>
        </View>
      </SafeAreaView>
    );
  }

  const currentStepEntries = getCurrentStepEntries();
  const currentStep = steps[activeStepIndex];

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar backgroundColor="#3b82f6" barStyle="light-content" />
      
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={handleBackPress}>
          <Ionicons name="arrow-back" size={24} color="white" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Auditoria p√≥s-servi√ßo</Text>
        <View style={styles.headerRight} />
      </View>

      {/* Stage Navigation Menu */}
      <View style={styles.stageNavigationContainer}>
        {/* Indicadores de navega√ß√£o */}
        <View style={styles.navigationIndicators}>
          {/* Indicador esquerda - parte transl√∫cida do bot√£o anterior */}
          <View style={styles.leftIndicator}>
            {activeStepIndex > 0 && (
              <View style={styles.translucentButtonContainer}>
                <View style={styles.translucentButtonPart}>
                  <Text 
                    style={styles.translucentButtonText}
                    numberOfLines={2}
                  >
                    {(steps[activeStepIndex - 1]?.titulo || '').substring(0, 12)}
                  </Text>
                </View>
                {/* Linha verde para etapa conclu√≠da */}
                <View style={styles.completedIndicatorLine} />
              </View>
            )}
          </View>

          {/* Bot√£o central */}
          <View style={styles.centerButtonContainer}>
            <View style={styles.centerButtonWrapper}>
              <TouchableOpacity
                style={[
                  styles.centerStageButton,
                  styles.activeStageButton,
                ]}
                onPress={() => handleStepPress(activeStepIndex)}
              >
                <Text 
                  style={[
                    styles.centerStageButtonText,
                    styles.activeStageButtonText,
                  ]}
                >
                  {steps[activeStepIndex]?.titulo || ''}
                </Text>
              </TouchableOpacity>
              {/* Linha verde para etapa atual (em progresso) */}
              <View style={styles.currentIndicatorLine} />
            </View>
          </View>

          {/* Indicador direita - parte transl√∫cida do bot√£o pr√≥ximo */}
          <View style={styles.rightIndicator}>
            {activeStepIndex < steps.length - 1 && (
              <View style={styles.translucentButtonContainer}>
                <View style={styles.translucentButtonPart}>
                  <Text 
                    style={styles.translucentButtonText}
                    numberOfLines={2}
                  >
                    {(steps[activeStepIndex + 1]?.titulo || '').substring(0, 12)}
                  </Text>
                </View>
                {/* Linha cinza para etapa pendente */}
                <View style={styles.pendingIndicatorLine} />
              </View>
            )}
          </View>
        </View>
      </View>

      {/* Photo Grid */}
      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        <View style={styles.photoGrid}>
          {currentStepEntries.map((entry: PhotoEntry) => renderPhotoCard(entry))}
        </View>
        
        {/* NOVA FUNCIONALIDADE: Fotos Extras Din√¢micas */}
        {steps.length > 0 && (
          <View style={styles.extraPhotosSection}>
            <Text style={styles.extraPhotosSectionTitle}>Fotos Extras</Text>
            <Text style={styles.extraPhotosSectionSubtitle}>
              Adicione fotos extras se necess√°rio (opcional)
            </Text>
            
            {/* Renderizar containers de fotos extras existentes */}
            {extraPhotoEntries[steps[activeStepIndex]?.id] && (
              <View style={styles.extraPhotoGrid}>
                {extraPhotoEntries[steps[activeStepIndex].id].map((extraEntry: ExtraPhotoEntry) => renderExtraPhotoCard(extraEntry))}
              </View>
            )}
            
            {/* Bot√£o para adicionar nova foto extra */}
            <TouchableOpacity
              style={styles.addExtraPhotoButton}
              onPress={() => addExtraPhotoEntry(steps[activeStepIndex].id)}
            >
              <Ionicons name="add-circle" size={24} color="#3b82f6" />
              <Text style={styles.addExtraPhotoButtonText}>Adicionar Foto Extra</Text>
            </TouchableOpacity>
          </View>
        )}
        
        {currentStepEntries.length === 0 && (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>Nenhuma entrada de foto para esta etapa</Text>
          </View>
        )}
      </ScrollView>

      {/* Campo de Coment√°rio */}
      <View style={styles.commentContainer}>
        <Text style={styles.commentLabel}>Deseja falar mais sobre esta etapa?</Text>
        <TextInput
          style={styles.commentInput}
          placeholder="Digite aqui..."
          placeholderTextColor="#9CA3AF"
          multiline
          numberOfLines={3}
          value={comentarios[steps[activeStepIndex]?.id] || ''}
          onChangeText={updateComentario}
          textAlignVertical="top"
        />
      </View>

      {/* Navigation Buttons */}
      <View style={styles.navigationContainer}>
        <TouchableOpacity
          style={[styles.navButton, styles.previousButton]}
          onPress={handleBackPress}
        >
          <Text style={styles.previousButtonText}>
            Voltar
          </Text>
        </TouchableOpacity>

        {activeStepIndex === steps.length - 1 ? (
          <TouchableOpacity
            style={[styles.navButton, styles.finishButton]}
            onPress={handleFinish}
          >
            <Text style={styles.finishButtonText}>Pr√≥ximo</Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity
            style={[styles.navButton, styles.nextButton]}
            onPress={handleNext}
          >
            <Text style={styles.nextButtonText}>Pr√≥ximo</Text>
          </TouchableOpacity>
        )}
      </View>

      {/* Modal de Foto Modelo em Tela Cheia */}
      <Modal
        visible={showModelPhotoModal}
        animationType="fade"
        onRequestClose={closeModelPhotoModal}
      >
        <SafeAreaView style={styles.modalContainer}>
          <StatusBar backgroundColor="black" barStyle="light-content" />
          
          {/* Header do Modal */}
          <View style={styles.modalHeader}>
            <TouchableOpacity style={styles.modalCloseButton} onPress={closeModelPhotoModal}>
              <Ionicons name="close" size={24} color="white" />
            </TouchableOpacity>
          </View>

          {/* Foto Modelo */}
          <View style={styles.modalImageContainer}>
            {selectedEntryForModel?.fotoModelo && (
              <Image
                source={{ uri: formatPhotoUri(selectedEntryForModel.fotoModelo) }}
                style={styles.modalImage}
                resizeMode="contain"
              />
            )}
          </View>

          {/* Texto Explicativo */}
          <View style={styles.modalTextContainer}>
            <Text style={styles.modalTitle}>Foto Modelo</Text>
            <Text style={styles.modalDescription}>
              Esta √© uma foto modelo a ser seguida. Use-a como refer√™ncia para capturar sua foto.
            </Text>
          </View>

          {/* Bot√µes de A√ß√£o */}
          <View style={styles.modalButtonContainer}>
            <TouchableOpacity style={styles.modalBackButton} onPress={closeModelPhotoModal}>
              <Text style={styles.modalBackButtonText}>Voltar</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.modalTakePhotoButton} onPress={takePhotoFromModal}>
              <Ionicons name="camera" size={20} color="white" style={styles.modalButtonIcon} />
              <Text style={styles.modalTakePhotoButtonText}>Tirar Foto</Text>
            </TouchableOpacity>
          </View>
        </SafeAreaView>
      </Modal>

      {/* Modal de Foto Atual em Tela Cheia */}
      <Modal
        visible={showCurrentPhotoModal}
        animationType="fade"
        onRequestClose={closeCurrentPhotoModal}
      >
        <SafeAreaView style={styles.modalContainer}>
          <StatusBar backgroundColor="black" barStyle="light-content" />
          
          {/* Foto Atual - Ocupa mais espa√ßo sem header e texto */}
          <View style={styles.modalImageContainerFullscreen}>
            {selectedEntryForCurrent && (
              <Image
                source={{ 
                  uri: collectedPhotos[selectedEntryForCurrent.id] || fotosSalvasUsuario[selectedEntryForCurrent.id] 
                }}
                style={styles.modalImage}
                resizeMode="contain"
              />
            )}
          </View>

          {/* Bot√µes de A√ß√£o */}
          <View style={styles.modalButtonContainer}>
            <TouchableOpacity style={styles.modalBackButton} onPress={closeCurrentPhotoModal}>
              <Text style={styles.modalBackButtonText}>Voltar</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.modalRemovePhotoButton} onPress={removePhotoFromModal}>
              <Ionicons name="trash" size={20} color="white" style={styles.modalButtonIcon} />
              <Text style={styles.modalRemovePhotoButtonText}>Remover Foto</Text>
            </TouchableOpacity>
          </View>
        </SafeAreaView>
      </Modal>

      {/* Modal de Foto Extra em Tela Cheia */}
      <Modal
        visible={showExtraPhotoModal}
        animationType="fade"
        onRequestClose={closeExtraPhotoModal}
      >
        <SafeAreaView style={styles.modalContainer}>
          <StatusBar backgroundColor="black" barStyle="light-content" />
          
          {/* Header do Modal */}
          <View style={styles.modalHeader}>
            <TouchableOpacity style={styles.modalCloseButton} onPress={closeExtraPhotoModal}>
              <Ionicons name="close" size={24} color="white" />
            </TouchableOpacity>
          </View>

          {/* Foto Extra */}
          <View style={styles.modalImageContainer}>
            {selectedExtraEntry && selectedExtraEntry.photoUri && (
              <Image
                source={{ uri: selectedExtraEntry.photoUri }}
                style={styles.modalImage}
                resizeMode="contain"
              />
            )}
          </View>

          {/* Texto Explicativo */}
          <View style={styles.modalTextContainer}>
            <Text style={styles.modalTitle}>Foto Extra</Text>
            <Text style={styles.modalDescription}>
              Esta √© uma foto extra a ser capturada. Use-a como refer√™ncia para capturar sua foto.
            </Text>
          </View>

          {/* Bot√µes de A√ß√£o */}
          <View style={styles.modalButtonContainer}>
            <TouchableOpacity style={styles.modalBackButton} onPress={closeExtraPhotoModal}>
              <Text style={styles.modalBackButtonText}>Voltar</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.modalTakePhotoButton} onPress={takeExtraPhotoFromModal}>
              <Ionicons name="camera" size={20} color="white" style={styles.modalButtonIcon} />
              <Text style={styles.modalTakePhotoButtonText}>Tirar Foto</Text>
            </TouchableOpacity>

            <TouchableOpacity style={styles.modalRemovePhotoButton} onPress={removeExtraPhotoFromModal}>
              <Ionicons name="trash" size={20} color="white" style={styles.modalButtonIcon} />
              <Text style={styles.modalRemovePhotoButtonText}>Remover Foto</Text>
            </TouchableOpacity>
          </View>
        </SafeAreaView>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingVertical: 15,
    backgroundColor: '#3b82f6',
  },
  backButton: {
    padding: 5,
  },
  headerTitle: {
    fontSize: RFValue(18),
    fontWeight: 'bold',
    color: 'white',
  },
  headerRight: {
    width: 34,
  },
  stageNavigationContainer: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    backgroundColor: '#3b82f6', // Mesmo background do header
    borderBottomWidth: 1,
    borderBottomColor: '#2563eb',
  },
  navigationIndicators: {
    flexDirection: 'row',
    alignItems: 'stretch',
    justifyContent: 'center',
    paddingHorizontal: 10,
  },
  leftIndicator: {
    flexDirection: 'row',
    alignItems: 'stretch',
    justifyContent: 'flex-end',
    paddingRight: 8,
    width: 88, // Largura fixa para sempre reservar espa√ßo (80px + 8px padding)
  },
  centerButtonContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  rightIndicator: {
    flexDirection: 'row',
    alignItems: 'stretch',
    justifyContent: 'flex-start',
    paddingLeft: 8,
    width: 88, // Largura fixa para sempre reservar espa√ßo (80px + 8px padding)
  },
  translucentButtonContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
  },
  translucentButtonPart: {
    paddingHorizontal: 8,
    paddingVertical: 8,
    borderRadius: 8,
    backgroundColor: 'rgba(59, 130, 246, 0.3)',
    borderWidth: 1,
    borderColor: 'rgba(59, 130, 246, 0.5)',
    alignItems: 'center',
    justifyContent: 'center',
    width: 80,
    flex: 1,
    overflow: 'hidden',
    marginBottom: 4,
  },
  translucentButtonText: {
    fontSize: RFValue(8),
    fontWeight: '600',
    color: '#ffffff',
    textAlign: 'center',
    lineHeight: 12,
  },
  content: {
    flex: 1,
    paddingHorizontal: 20,
  },
  photoGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    paddingVertical: 20,
  },
  photoCard: {
    width: (width - 60) / 2,
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    position: 'relative',
  },
  photoCardTitleContainer: {
    marginBottom: 10,
    alignItems: 'center',
    justifyContent: 'center',
  },
  photoCardTitle: {
    fontSize: RFValue(12),
    fontWeight: '600',
    color: '#374151',
    textAlign: 'center',
  },
  photoContainer: {
    width: '100%',
    height: 180,
    position: 'relative',
  },
  photoArea: {
    width: '100%',
    height: '100%',
    backgroundColor: '#f3f4f6',
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#000000',
    borderStyle: 'dashed',
    alignItems: 'center',
    justifyContent: 'center',
  },
  photoAreaWithCapturedImage: {
    borderStyle: 'solid',
    borderColor: '#10b981',
    backgroundColor: 'transparent',
  },
  photoImage: {
    width: '100%',
    height: '100%',
    borderRadius: 6,
  },
  removePhotoButton: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: 'white',
    borderRadius: 15,
    width: 30,
    height: 30,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 3,
    elevation: 5,
  },
  emptyContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 40,
  },
  emptyText: {
    fontSize: RFValue(14),
    color: '#6b7280',
    textAlign: 'center',
  },
  navigationContainer: {
    flexDirection: 'row',
    paddingHorizontal: 20,
    paddingVertical: 15,
    backgroundColor: 'white',
    borderTopWidth: 1,
    borderTopColor: '#e5e7eb',
    gap: 10,
  },
  navButton: {
    flex: 1,
    paddingVertical: 15,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  previousButton: {
    backgroundColor: '#3b82f6',
  },
  nextButton: {
    backgroundColor: '#E0ED54',
  },
  finishButton: {
    backgroundColor: '#E0ED54',
  },
  previousButtonText: {
    fontSize: RFValue(14),
    fontWeight: '600',
    color: 'white',
  },
  nextButtonText: {
    fontSize: RFValue(14),
    fontWeight: '600',
    color: '#000000',
  },
  finishButtonText: {
    fontSize: RFValue(14),
    fontWeight: '600',
    color: '#000000',
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    fontSize: RFValue(16),
    color: '#6b7280',
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'black',
  },
  modalHeader: {
    position: 'absolute',
    top: 50,
    right: 20,
    zIndex: 1,
  },
  modalCloseButton: {
    padding: 10,
  },
  modalImageContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingTop: 80,
    paddingBottom: 200,
  },
  modalImage: {
    width: '90%',
    height: '100%',
  },
  modalTextContainer: {
    position: 'absolute',
    bottom: 120,
    left: 0,
    right: 0,
    padding: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.95)',
    alignItems: 'center',
  },
  modalTitle: {
    fontSize: RFValue(18),
    fontWeight: 'bold',
    color: '#374151',
    marginBottom: 8,
    textAlign: 'center',
  },
  modalDescription: {
    fontSize: RFValue(14),
    color: '#6b7280',
    textAlign: 'center',
    lineHeight: 20,
  },
  modalButtonContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    flexDirection: 'row',
    backgroundColor: 'white',
    paddingHorizontal: 20,
    paddingVertical: 20,
    paddingBottom: 40,
    gap: 15,
  },
  modalBackButton: {
    flex: 1,
    paddingVertical: 15,
    backgroundColor: '#f3f4f6',
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  modalBackButtonText: {
    fontSize: RFValue(14),
    fontWeight: '600',
    color: '#374151',
  },
  modalTakePhotoButton: {
    flex: 1,
    paddingVertical: 15,
    backgroundColor: '#3b82f6',
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
  },
  modalButtonIcon: {
    marginRight: 8,
  },
  modalTakePhotoButtonText: {
    fontSize: RFValue(14),
    fontWeight: '600',
    color: 'white',
  },
  centerStageButton: {
    paddingHorizontal: 20,
    paddingVertical: 8,
    borderRadius: 12,
    backgroundColor: '#3b82f6',
    borderWidth: 2,
    borderColor: '#3b82f6',
    shadowColor: '#3b82f6',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
    width: 250,
    minHeight: 48,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 4,
  },
  centerStageButtonText: {
    fontSize: RFValue(14),
    fontWeight: '600',
    color: 'white',
    textAlign: 'center',
  },
  activeStageButton: {
    backgroundColor: '#3b82f6',
    borderColor: '#3b82f6',
  },
  activeStageButtonText: {
    color: 'white',
    fontWeight: '600',
  },
  centerButtonWrapper: {
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 56, // Altura m√≠nima para o container inteiro (bot√£o + linha)
  },
  currentIndicatorLine: {
    width: 250,
    height: 3,
    backgroundColor: '#10b981',
    borderRadius: 1,
  },
  completedIndicatorLine: {
    width: 80,
    height: 3,
    backgroundColor: '#10b981',
    borderRadius: 1,
  },
  pendingIndicatorLine: {
    width: 80,
    height: 3,
    backgroundColor: '#e5e7eb',
    borderRadius: 1,
  },
  commentContainer: {
    padding: 20,
    backgroundColor: 'white',
  },
  commentLabel: {
    fontSize: RFValue(14),
    fontWeight: '600',
    color: '#374151',
    marginBottom: 8,
  },
  commentInput: {
    backgroundColor: '#f3f4f6',
    borderRadius: 8,
    padding: 12,
    minHeight: 80,
    fontSize: RFValue(14),
    color: '#374151',
    borderWidth: 1,
    borderColor: '#e5e7eb',
  },
  modalRemovePhotoButton: {
    flex: 1,
    paddingVertical: 15,
    backgroundColor: '#ef4444',
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
  },
  modalRemovePhotoButtonText: {
    fontSize: RFValue(14),
    fontWeight: '600',
    color: 'white',
  },
  modalImageContainerFullscreen: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingTop: 80,
    paddingBottom: 200,
  },
  extraPhotosSection: {
    marginTop: 20,
    padding: 20,
    backgroundColor: '#f3f4f6',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    alignItems: 'center',
  },
  extraPhotosSectionTitle: {
    fontSize: RFValue(16),
    fontWeight: 'bold',
    color: '#374151',
    marginBottom: 8,
    textAlign: 'center',
  },
  extraPhotosSectionSubtitle: {
    fontSize: RFValue(12),
    color: '#6b7280',
    textAlign: 'center',
    marginBottom: 15,
  },
  addExtraPhotoButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 15,
    paddingHorizontal: 20,
    borderRadius: 10,
    backgroundColor: '#f9f9f9',
    borderWidth: 2,
    borderColor: '#3b82f6',
    borderStyle: 'dashed',
    width: '80%',
    maxWidth: 250,
    minHeight: 50,
  },
  addExtraPhotoButtonText: {
    fontSize: RFValue(14),
    fontWeight: '600',
    color: '#3b82f6',
    marginLeft: 10,
  },
  removeContainerButton: {
    position: 'absolute',
    top: 5,
    right: 5,
    backgroundColor: 'white',
    borderRadius: 15,
    width: 30,
    height: 30,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 3,
    elevation: 5,
  },
  extraPhotoGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    paddingVertical: 20,
    gap: 10,
  },
});

export default PhotoCollectionScreen; 